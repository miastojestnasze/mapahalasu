<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wykresy Hałasu MJN</title>
    <!-- Add D3.js for charts -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Add Figtree font -->
    <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Figtree', sans-serif;
            background-color: #f5f5f5;
        }

        .navbar {
            background-color: #FDF312;
            overflow: hidden;
            padding: 0;
            z-index: 1000;
            position: relative;
            display: flex;
            align-items: center;
        }

        .navbar a {
            float: left;
            color: #333;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
            font-size: 17px;
            font-family: 'Figtree', sans-serif;
            font-weight: 600;
            height: 100%;
            box-sizing: border-box;
        }

        .navbar a:hover {
            background-color: #e6dc10;
            color: black;
        }

        .navbar a.active {
            background-color: #e6dc10;
            color: black;
        }

        .navbar-logo {
            margin-left: auto;
            display: flex;
            align-items: center;
            height: 100%;
            padding: 0 15px;
        }

        .navbar-logo img {
            height: 30px;
            display: block;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333;
            margin: 0 0 10px 0;
        }

        .header img {
            max-width: 150px;
            margin: 15px auto;
            display: block;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
        }

        .chart-canvas {
            width: 100%;
            height: 500px;
        }

        .chart-svg {
            width: 100%;
            height: 500px;
        }

        .line {
            fill: none;
            stroke-width: 3px;
        }

        .dot {
            r: 4;
            opacity: 0.7;
        }

        .dot:hover {
            r: 6;
            opacity: 1;
        }

        .axis {
            font-size: 12px;
        }

        .axis-label {
            font-size: 14px;
            font-weight: 600;
        }

        .legend {
            font-size: 12px;
            font-weight: 500;
        }

        .legend-item {
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.3s;
        }

        .legend-item.disabled {
            opacity: 0.3;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .loading-indicator {
            text-align: center;
            padding: 50px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .error-message {
            text-align: center;
            padding: 50px;
            background: #ffebee;
            border-radius: 10px;
            color: #c62828;
            display: none;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        .controls label {
            margin-right: 10px;
            font-weight: 500;
        }

        .controls select {
            padding: 8px 12px;
            margin-right: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Figtree', sans-serif;
        }

        .sensor-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .sensor-controls h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #333;
        }

        .sensor-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            text-align: left;
        }

        .sensor-checkbox {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        .sensor-checkbox:hover {
            background-color: #f8f9fa;
        }

        .sensor-checkbox input[type="checkbox"] {
            margin-right: 10px;
            width: 16px;
            height: 16px;
        }

        .sensor-checkbox label {
            margin: 0;
            cursor: pointer;
            font-weight: 400;
            flex: 1;
        }

        .sensor-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-left: 10px;
        }

        .refresh-button {
            padding: 10px 20px;
            background-color: #FDF312;
            color: #333;
            border: none;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .refresh-button:hover {
            background-color: #e6dc10;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #a18ffa;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <!-- Navigation Bar -->
    <div class="navbar">
        <a href="static.html">Mapa</a>
        <a href="omapie.html">O mapie</a>
        <a href="wykresy.html" class="active">Wykresy</a>
        <!-- Logo on the right side -->
        <div class="navbar-logo">
            <img src="logo.png" alt="Logo">
        </div>
    </div>

    <div class="container">
        <!-- Controls -->
        <div class="controls">
            <div>
                <label for="timeRange">Zakres czasowy:</label>
                <select id="timeRange">
                    <option value="24">Ostatnie 24 godziny</option>
                    <option value="168">Ostatni tydzień</option>
                    <option value="720">Ostatni miesiąc</option>
                </select>
                
                <button id="refreshButton" class="refresh-button">Odśwież dane</button>
            </div>
            
            <div class="sensor-controls">
                <h4>Wybierz czujniki do wyświetlenia:</h4>
                <div class="sensor-checkboxes" id="sensorCheckboxes">
                    <!-- Checkboxes will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Statistics -->
        <div class="stats-grid" id="statsGrid">
            <!-- Stats will be populated by JavaScript -->
        </div>

        <!-- Loading indicator -->
        <div id="loading" class="loading-indicator">
            <h3>Ładowanie danych...</h3>
            <p>Pobieranie danych z sensorów...</p>
        </div>

        <!-- Error message -->
        <div id="error" class="error-message">
            <h3>Błąd ładowania danych</h3>
            <p>Wystąpił problem podczas pobierania danych z serwera.</p>
        </div>

        <!-- Charts Grid -->
        <div class="charts-grid" id="chartsGrid" style="display: none;">
            <!-- Charts will be populated by JavaScript -->
        </div>
    </div>

    <script>
        // Sensor configuration
        const sensorNames = {
            'mjn-u-cz1': {
                'adres': 'Ursus, ul. Orląt Lwowskich', 
                'latitude': 52.19140609168865,
                'longitude': 20.865002342426457
            },
            'mjn-cz-noise-2': {
                'adres': 'Wola, ul. Łucka',
                'latitude': 52.23311543627833,                                  
                'longitude': 20.99141499475493
            },
            'mjn-cz-noise-5': {
                'adres': 'Mokotów, ul. Puławska', 
                'latitude': 52.18535469628882,                                  
                'longitude': 21.02372229587361
            },
            'mjn-cz-noise-3': {
                'adres': 'Śródmieście, ul. Emilii Plater',
                'latitude': 52.232191391261274,
                'longitude': 21.00288934332785
            },
            'mjn-cz-noise-4': {
                'adres': 'Wola, ul. Goleszowska',
                'latitude': 52.224962408624435,
                'longitude': 20.938818834103355
            },
            'mjn-cz-noise-6': {
                'adres': 'Ochota, ul. Kaliska',
                'latitude': 52.217533714571736,
                'longitude': 20.981149891932496
            },
            'mjn-cz-noise-7': {
                'adres': 'Wola, Aleja Prymasa Tysiąclecia',
                'latitude': 52.23177015793386,
                'longitude': 20.955453755574585
            }
        };

        // Color palette for different sensors
        const sensorColors = [
            '#a18ffa', '#ff6b6b', '#4ecdc4', '#45b7d1', 
            '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'
        ];

        let allSensorData = [];
        let chartSvg = null;
        let activeDatasets = new Set(); // Track which datasets are currently visible
        let availableSensors = new Set(); // Track which sensors have data

        // Fetch sensor data from the server
        function fetchData() {
            const apiUrl = new URL('https://vps-76e4aba0.vps.ovh.net/samples');
            apiUrl.searchParams.append('offset', '503300');
            apiUrl.searchParams.append('limit', '30000000');

            return fetch(apiUrl.toString())
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    allSensorData = data;
                    return data;
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    throw error;
                });
        }

        // Filter data based on time range
        function filterDataByTimeRange(data, hoursBack) {
            const currentTimestamp = Math.floor(Date.now() / 1000);
            const cutoffTimestamp = currentTimestamp - (hoursBack * 3600);
            
            return data.filter(reading => reading.timestamp >= cutoffTimestamp);
        }

        // Group data by sensor
        function groupDataBySensor(data) {
            const grouped = {};
            
            data.forEach(reading => {
                if (!grouped[reading.id]) {
                    grouped[reading.id] = [];
                }
                grouped[reading.id].push(reading);
            });

            // Sort each sensor's data by timestamp
            Object.keys(grouped).forEach(sensorId => {
                grouped[sensorId].sort((a, b) => a.timestamp - b.timestamp);
            });

            return grouped;
        }

        // Calculate statistics
        function calculateStats(data) {
            if (data.length === 0) return {};

            const noiseLevels = data.map(reading => reading.Lmax || reading.loudness || 0);
            const validLevels = noiseLevels.filter(level => level > 0);

            if (validLevels.length === 0) return {};

            const avg = validLevels.reduce((sum, level) => sum + level, 0) / validLevels.length;
            const max = Math.max(...validLevels);
            const min = Math.min(...validLevels);

            return {
                average: avg.toFixed(1),
                maximum: max.toFixed(1),
                minimum: min.toFixed(1),
                readings: validLevels.length
            };
        }

        // Display statistics
        function displayStats(groupedData) {
            const statsGrid = document.getElementById('statsGrid');
            const timeRange = parseInt(document.getElementById('timeRange').value);
            
            // Calculate overall stats
            let allReadings = [];
            Object.values(groupedData).forEach(sensorData => {
                allReadings = allReadings.concat(sensorData);
            });

            const overallStats = calculateStats(allReadings);
            const activeSensors = Object.keys(groupedData).length;

            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${activeSensors}</div>
                    <div class="stat-label">Aktywne sensory</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${overallStats.readings || 0}</div>
                    <div class="stat-label">Łączna liczba pomiarów</div>
                </div>
            `;
        }

        // Create sensor checkboxes
        function createSensorCheckboxes(groupedData) {
            const checkboxContainer = document.getElementById('sensorCheckboxes');
            checkboxContainer.innerHTML = '';

            // Update available sensors
            availableSensors.clear();
            Object.keys(groupedData).forEach(sensorId => {
                if (groupedData[sensorId].length > 0) {
                    availableSensors.add(sensorId);
                }
            });

            let colorIndex = 0;
            availableSensors.forEach(sensorId => {
                const sensorName = sensorNames[sensorId] ? sensorNames[sensorId].adres : sensorId;
                const color = sensorColors[colorIndex % sensorColors.length];
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'sensor-checkbox';
                
                const isChecked = activeDatasets.has(sensorId) ? 'checked' : '';
                
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="sensor-${sensorId}" ${isChecked} 
                           onchange="toggleSensorFromCheckbox('${sensorId}')">
                    <label for="sensor-${sensorId}">${sensorName}</label>
                    <div class="sensor-color" style="background-color: ${color};"></div>
                `;
                
                checkboxContainer.appendChild(checkboxDiv);
                colorIndex++;
            });
        }

        // Toggle sensor from checkbox
        function toggleSensorFromCheckbox(sensorId) {
            const checkbox = document.getElementById(`sensor-${sensorId}`);
            
            if (checkbox.checked) {
                activeDatasets.add(sensorId);
            } else {
                activeDatasets.delete(sensorId);
            }
            
            // Update chart visibility
            updateChartVisibility();
        }

        // Update chart visibility based on active datasets
        function updateChartVisibility() {
            if (!chartSvg) return;
            
            availableSensors.forEach(sensorId => {
                const lineGroup = d3.select(`.sensor-${sensorId}`);
                const legendItem = d3.selectAll('.legend-item').filter(d => d.id === sensorId);
                
                if (activeDatasets.has(sensorId)) {
                    lineGroup.style('opacity', 1);
                    legendItem.classed('disabled', false);
                } else {
                    lineGroup.style('opacity', 0.1);
                    legendItem.classed('disabled', true);
                }
            });
        }
        // Create all charts
        function createCharts(groupedData) {
            const chartsGrid = document.getElementById('chartsGrid');
            chartsGrid.innerHTML = '';

            // Initialize active datasets - by default, show all available sensors
            activeDatasets.clear();
            Object.keys(groupedData).forEach(sensorId => {
                if (groupedData[sensorId].length > 0) {
                    activeDatasets.add(sensorId);
                }
            });

            // Create sensor checkboxes
            createSensorCheckboxes(groupedData);

            // Create only ONE chart container for all sensors
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            chartContainer.innerHTML = `
                <div id="chart-container" style="position: relative;">
                    <svg id="combined-chart" class="chart-svg"></svg>
                    <div id="tooltip" class="tooltip"></div>
                </div>
            `;

            chartsGrid.appendChild(chartContainer);

            // Create the combined chart
            setTimeout(() => {
                createD3Chart(groupedData);
            }, 10);
        }

        // Create a D3.js chart for all sensors
        function createD3Chart(groupedData) {
            const svg = d3.select('#combined-chart');
            svg.selectAll('*').remove(); // Clear previous chart

            const container = document.getElementById('chart-container');
            const margin = { top: 80, right: 100, bottom: 60, left: 60 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const chartGroup = svg
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Prepare data
            const datasets = [];
            let colorIndex = 0;

            Object.keys(groupedData).forEach(sensorId => {
                const sensorData = groupedData[sensorId];
                if (sensorData.length === 0) return;

                const sensorName = sensorNames[sensorId] ? sensorNames[sensorId].adres : sensorId;
                const color = sensorColors[colorIndex % sensorColors.length];

                const dataPoints = sensorData.map(reading => ({
                    date: new Date(reading.timestamp * 1000),
                    value: reading.Lmax || reading.loudness || 0,
                    sensor: sensorId,
                    sensorName: sensorName
                }));

                datasets.push({
                    id: sensorId,
                    name: sensorName,
                    color: color,
                    data: dataPoints
                });

                colorIndex++;
            });

            // Set up scales
            const allData = datasets.flatMap(d => d.data);
            const xScale = d3.scaleTime()
                .domain(d3.extent(allData, d => d.date))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([30, 80])
                .range([height, 0]);

            // Create axes
            const xAxis = d3.axisBottom(xScale)
                .ticks(8)
                .tickFormat(d3.timeFormat('%H:%M'));

            const yAxis = d3.axisLeft(yScale)
                .ticks(8);

            chartGroup.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis);

            chartGroup.append('g')
                .attr('class', 'axis')
                .call(yAxis);

            // Add axis labels
            chartGroup.append('text')
                .attr('class', 'axis-label')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Poziom hałasu (dB)');

            chartGroup.append('text')
                .attr('class', 'axis-label')
                .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 10})`)
                .style('text-anchor', 'middle')
                .text('Czas');

            // Create line generator
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.value))
                .curve(d3.curveCardinal);

            // Add tooltip
            const tooltip = d3.select('#tooltip');

            // Draw lines for each sensor
            datasets.forEach(dataset => {
                const lineGroup = chartGroup.append('g')
                    .attr('class', `line-group sensor-${dataset.id}`);

                // Draw line
                lineGroup.append('path')
                    .datum(dataset.data)
                    .attr('class', 'line')
                    .attr('d', line)
                    .style('stroke', dataset.color);

                // Add dots
                lineGroup.selectAll('.dot')
                    .data(dataset.data)
                    .enter().append('circle')
                    .attr('class', 'dot')
                    .attr('cx', d => xScale(d.date))
                    .attr('cy', d => yScale(d.value))
                    .style('fill', dataset.color)
                    .on('mouseover', function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        
                        tooltip.html(`
                            <strong>${d.sensorName}</strong><br/>
                            Poziom: ${d.value.toFixed(1)} dB<br/>
                            Czas: ${d.date.toLocaleString('pl-PL')}
                        `)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        tooltip.transition()
                            .duration(500)
                            .style('opacity', 0);
                    });
            });

            // Create legend
            const legend = chartGroup.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width + 20}, 20)`);

            const legendItems = legend.selectAll('.legend-item')
                .data(datasets)
                .enter().append('g')
                .attr('class', 'legend-item')
                .attr('transform', (d, i) => `translate(0, ${i * 25})`)
                .style('cursor', 'pointer')
                .on('click', function(event, d) {
                    toggleDataset(d.id);
                });

            legendItems.append('rect')
                .attr('width', 18)
                .attr('height', 18)
                .style('fill', d => d.color);

            legendItems.append('text')
                .attr('x', 24)
                .attr('y', 9)
                .attr('dy', '0.35em')
                .text(d => d.name);

            // Function to toggle dataset visibility (from legend clicks)
            function toggleDataset(sensorId) {
                const checkbox = document.getElementById(`sensor-${sensorId}`);
                
                if (activeDatasets.has(sensorId)) {
                    // Hide dataset
                    activeDatasets.delete(sensorId);
                    if (checkbox) checkbox.checked = false;
                } else {
                    // Show dataset
                    activeDatasets.add(sensorId);
                    if (checkbox) checkbox.checked = true;
                }
                
                updateChartVisibility();
            }

            chartSvg = svg;
        }

        // Main function to load and display data
        function loadData() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('chartsGrid').style.display = 'none';

            fetchData()
                .then(data => {
                    const timeRange = parseInt(document.getElementById('timeRange').value);
                    const filteredData = filterDataByTimeRange(data, timeRange);
                    const groupedData = groupDataBySensor(filteredData);

                    // Remove sensor mjn-cz-noise-7 if needed (uncomment the line below)
                    // delete groupedData['mjn-cz-noise-7'];

                    displayStats(groupedData);
                    createCharts(groupedData);

                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('chartsGrid').style.display = 'grid';
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('error').style.display = 'block';
                });
        }

        // Event listeners
        document.getElementById('timeRange').addEventListener('change', loadData);
        document.getElementById('refreshButton').addEventListener('click', loadData);

        // Initial load
        loadData();

        // Auto-refresh every 3 minutes
        setInterval(loadData, 180000);
    </script>
</body>

</html>
